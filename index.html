import React, { useEffect, useMemo, useRef, useState } from "react";

// ===== ì‚¬ìì„±ì–´ ë°ì´í„° (ê°„ëµí™” ë²„ì „) =====
const IDIOMS = [
  { id: 1, term: "ì ˆì°¨íƒë§ˆ(åˆ‡ç£‹ç¢ç£¨)", meaning: "ì„œë¡œ ë°°ìš°ë©° ê°ˆê³ ë‹¦ì•„ í–¥ìƒí•¨.", origin: "ì‹œê²½/ì˜ˆê¸°", tags: ["ìˆ˜ì–‘","ê³µë¶€"] },
  { id: 2, term: "í˜•ì„¤ì§€ê³µ(è¢é›ªä¹‹åŠŸ)", meaning: "ê³ ìƒí•˜ë©° í•™ë¬¸ì„ ì´ë£¨ëŠ” ê³µ.", origin: "ì§„ì„œ/ìˆ˜ê²½ì£¼", tags: ["ê·¼ë©´","ê³µë¶€"] },
  { id: 3, term: "ê·¼ë¬µìí‘(è¿‘å¢¨è€…é»‘)", meaning: "ë¨¹ì„ ê°€ê¹Œì´í•˜ë©´ ê²€ì–´ì§„ë‹¤(í™˜ê²½ì˜ ì˜í–¥).", origin: "íƒœìì†Œë¶€", tags: ["ìê¸°ê´€ë¦¬"] },
  { id: 4, term: "ëŒ€ê¸°ë§Œì„±(å¤§å™¨æ™©æˆ)", meaning: "í° ê·¸ë¦‡ì€ ëŠ¦ê²Œ ì´ë£¨ì–´ì§.", origin: "ë…¸ì", tags: ["ì¸ë‚´","ì„±ì¥"] },
  { id: 5, term: "ë°±ì ˆë¶ˆêµ´(ç™¾æŠ˜ä¸å±ˆ)", meaning: "ë°± ë²ˆ êº¾ì—¬ë„ êµ½íˆì§€ ì•ŠìŒ.", origin: "í›„í•œì„œ", tags: ["ì˜ì§€","ì¸ë‚´"] },
  { id: 6, term: "ì˜¨ê³ ì§€ì‹ (æº«æ•…çŸ¥æ–°)", meaning: "ì˜›ê²ƒì„ ìµí˜€ ìƒˆê²ƒì„ ì•ˆë‹¤.", origin: "ë…¼ì–´", tags: ["í•™ìŠµ"] },
  { id: 7, term: "ìœ ì§€ê²½ì„±(æœ‰å¿—ç«Ÿæˆ)", meaning: "ëœ»ì´ ìˆìœ¼ë©´ ë§ˆì¹¨ë‚´ ì´ë£¸.", origin: "í›„í•œì„œ", tags: ["ì˜ì§€"] },
  { id: 8, term: "ì²­ì¶œì–´ëŒ(é‘å‡ºæ–¼è—)", meaning: "ì œìê°€ ìŠ¤ìŠ¹ë³´ë‹¤ ë” ë‚˜ìŒ.", origin: "ìˆœì", tags: ["ì„±ì¥"] },
  { id: 9, term: "ì´ˆì§€ì¼ê´€(åˆå¿—ä¸€è²«)", meaning: "ì²˜ìŒ ì„¸ìš´ ëœ»ì„ ëê¹Œì§€ ë°€ê³  ë‚˜ê°.", origin: "í›„í•œì„œ", tags: ["ì˜ì§€"] },
  { id: 10, term: "ì‚¬í•„ê·€ì •(äº‹å¿…æ­¸æ­£)", meaning: "ëª¨ë“  ì¼ì€ ê²°êµ­ ë°”ë¥¸ ë°ë¡œ ëŒì•„ê°.", origin: "ì—­ì‚¬ì„œ í†µìš©", tags: ["ì •ì˜"] },
];

const shuffle = (arr) => {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
};

export default function App() {
  const [query, setQuery] = useState("");
  const [order, setOrder] = useState(() => shuffle(IDIOMS.map((x) => x.id)));
  const [idx, setIdx] = useState(0);
  const [back, setBack] = useState(false);
  const [soundOn, setSoundOn] = useState(true);
  const audioCtxRef = useRef(null);

  const filtered = useMemo(() => {
    const q = query.trim();
    const all = order.map((id) => IDIOMS.find((x) => x.id === id));
    return all.filter((i) => {
      if (!q) return true;
      const hay = `${i.term} ${i.meaning} ${i.origin}`;
      return hay.toLowerCase().includes(q.toLowerCase());
    });
  }, [order, query]);

  const cur = filtered[idx % Math.max(filtered.length, 1)] || IDIOMS[0];

  const playFlip = () => {
    if (!soundOn) return;
    try {
      const ctx = audioCtxRef.current || new (window.AudioContext || window.webkitAudioContext)();
      audioCtxRef.current = ctx;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.15);
    } catch (e) {}
  };

  const nextCard = () => { setBack(false); setIdx((v) => (v + 1) % filtered.length); };
  const prevCard = () => { setBack(false); setIdx((v) => (v - 1 + filtered.length) % filtered.length); };
  const reshuffle = () => { setOrder(shuffle(IDIOMS.map((x) => x.id))); setIdx(0); setBack(false); };

  return (
    <div style={styles.page}>
      <h1 style={styles.title}>ğŸ€„ í˜¸ë§ˆë§¨ ì‚¬ìì„±ì–´</h1>
      <div style={styles.toolbar}>
        <input
          placeholder="ê²€ìƒ‰(ìš©ì–´/ëœ»/ìœ ë˜)"
          value={query}
          onChange={(e) => { setQuery(e.target.value); setIdx(0); }}
          style={styles.input}
        />
        <button onClick={reshuffle} style={styles.btn}>ğŸ”€ ì…”í”Œ</button>
        <button onClick={() => { setBack(!back); playFlip(); }} style={styles.btn}>â†©ï¸ ë’¤ì§‘ê¸°</button>
        <label style={styles.inlineLabel}>
          <input type="checkbox" checked={soundOn} onChange={(e) => setSoundOn(e.target.checked)} /> ì‚¬ìš´ë“œ
        </label>
      </div>

      <div style={styles.cardWrap}>
        <button onClick={prevCard} style={styles.navBtn}>â—€</button>

        <FlipCard back={back} onClick={() => { setBack(!back); playFlip(); }}>
          <CardFront term={cur.term} />
          <CardBack meaning={cur.meaning} origin={cur.origin} />
        </FlipCard>

        <button onClick={nextCard} style={styles.navBtn}>â–¶</button>
      </div>

      <div style={styles.meta}>ì¹´ë“œ {idx + 1}/{filtered.length}</div>
      <style>{css}</style>
    </div>
  );
}

function CardFront({ term }) {
  return (
    <div style={styles.cardFace}>
      <div style={{ fontSize: 40, fontWeight: 800 }}>{term}</div>
      <div style={{ marginTop: 12, fontSize: 16, opacity: 0.6 }}>ì¹´ë“œë¥¼ í´ë¦­í•˜ê±°ë‚˜ ë’¤ì§‘ê¸° ë²„íŠ¼ì„ ëˆŒëŸ¬ ëœ» ë³´ê¸°</div>
    </div>
  );
}

function CardBack({ meaning, origin }) {
  return (
    <div style={styles.cardFace}>
      <div style={{ fontSize: 22, fontWeight: 700 }}>{meaning}</div>
      <div style={{ marginTop: 10, fontSize: 15, opacity: 0.7 }}>ìœ ë˜: {origin}</div>
    </div>
  );
}

function FlipCard({ back, onClick, children }) {
  return (
    <div style={styles.scene} onClick={onClick}>
      <div className={back ? "card is-flipped" : "card"}>
        <div className="card__face card__face--front">{children[0]}</div>
        <div className="card__face card__face--back">{children[1]}</div>
      </div>
    </div>
  );
}

const styles = {
  page: { fontFamily: "Pretendard, system-ui, -apple-system, Segoe UI, Roboto, sans-serif", maxWidth: 920, margin: "32px auto", padding: "0 16px", background: "#faf7ef" },
  title: { fontSize: 32, fontWeight: 800, marginBottom: 12 },
  toolbar: { display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap", marginBottom: 12 },
  input: { flex: 1, minWidth: 220, padding: "10px 12px", borderRadius: 10, border: "1px solid #cbbfa8", background: "#fffdf7" },
  btn: { padding: "10px 14px", borderRadius: 10, border: "1px solid #6b6658", background: "#fcfaf3", cursor: "pointer" },
  inlineLabel: { display: "flex", alignItems: "center", gap: 6, fontSize: 14, opacity: 0.85 },
  cardWrap: { display: "grid", gridTemplateColumns: "60px 1fr 60px", gap: 12, alignItems: "center", margin: "16px 0" },
  navBtn: { width: 50, height: 50, borderRadius: 14, border: "1px solid #6b6658", background: "#fcfaf3", cursor: "pointer", fontSize: 20 },
  scene: { width: "100%", maxWidth: 600, height: 280, perspective: 1000, margin: "0 auto" },
  cardFace: { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", padding: 20, textAlign: "center" },
  meta: { marginTop: 8, fontSize: 14, opacity: 0.7 },
};

const css = `
.card {
  width: 100%;
  height: 100%;
  position: relative;
  transition: transform 0.6s;
  transform-style: preserve-3d;
  border-radius: 22px;
  box-shadow: 0 12px 28px rgba(0,0,0,0.08), 0 6px 14px rgba(0,0,0,0.05);
  border: 1px solid #cdbfa6;
}
.card.is-flipped { transform: rotateY(180deg); }
.card__face {
  position: absolute; inset: 0; backface-visibility: hidden; border-radius: 22px;
  background-color: #fffaf1;
  background-image:
    radial-gradient(rgba(0,0,0,0.03) 0.6px, rgba(0,0,0,0) 0.6px),
    radial-gradient(rgba(0,0,0,0.025) 0.8px, rgba(0,0,0,0) 0.8px),
    repeating-linear-gradient(25deg, rgba(136,112,88,0.06) 0 2px, rgba(136,112,88,0.02) 2px 6px),
    repeating-linear-gradient(-18deg, rgba(136,112,88,0.05) 0 3px, rgba(136,112,88,0.02) 3px 7px);
  background-size: 6px 6px, 11px 11px, 100% 100%, 100% 100%;
}
.card__face--back { transform: rotateY(180deg); }
`;
